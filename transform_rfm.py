# -*- coding: utf-8 -*-
"""transform_rfm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wOSTDxdit4z0HBSbns4AwFDlYM_lDGVk
"""

import pandas as pd
from datetime import datetime
from numpy import percentile
from sqlalchemy import *

engine = create_engine('postgresql://xxx:xxx@xxx.xxx.65.80:xxx/xxxx')
list_table = (engine.table_names())

for i in list_table:
  exec("%s = pd.read_sql_query('select * from %s' , con=engine)" % (i,i))

def conv_to_date1(column):
    try:
      conv_date = pd.to_datetime(column, format='%Y-%m-%d %H:%M:%S')
      return conv_date
    except:
      try:
        conv_date = pd.to_datetime(column, format='%d-%m-%y %H:%M')
        return conv_date
      except:
        print('error converting')
        pass

def conv_to_date2(column):
  try: 
    conv_date = pd.to_datetime(column, format='%d-%m-%y')
    return conv_date        
  except:
    try:
      conv_date = pd.to_datetime(column, format='%d-%m-%y %H:%M')
      return conv_date
    except:
      print('error converting')
      pass

def calc_days(df):
  delta = []
  for i in range(len(transaksi)):
    if df['item'][i] == 'car':
      delta.append((df['date_to_new'][i]-df['date_from_new'][i]).days+1)
    else:
      delta.append((df['date_to_new'][i]-df['date_from_new'][i]).days)
  return delta

#levelling
def levelling(kolom,standar) : 
  level = []
  for i in kolom : 
    if i > standar[3] : 
      level.append(5) 
    elif standar[2] < i <= standar[3] : 
      level.append(4)
    elif standar[1] < i <= standar[2] : 
      level.append(2) 
    elif standar[0] < i <= standar[1] : 
      level.append(2)
    else : 
      level.append(1)
  return level


#renaming column
lend_car_final_1 = lend_car_final_1.rename(columns={"rental_price": "price"})

#merge biar tau data transaksinya
df_motor = motor_tx_fixed.merge(lend_motors_complete, how = 'left', on = 'id_lend_motor')
df_regular = regular_tx.merge(lend_stuff_complete, how = 'left', on = 'id_lend')
df_car = car_tx.merge(lend_car_final_1, how='left',on='id_lend_car')

df_regular['item']='stuff'
df_motor['item']='motor'
df_car['item']='car'

#apa aja kolom yang sama dari ketiga tabel
kolom = []
for i in df_motor.columns : 
  if (i in df_regular.columns) and (i in df_car.columns): 
    kolom.append(i)

#menggabungkan semua tabel transaksi 
#jadinya gak ketauan si user nyewa apa, tapi bisa tau udah pake rentuff berapa kali
transaksi = pd.concat([df_motor, df_regular, df_car])
transaksi = transaksi[kolom]
transaksi = transaksi.reset_index(drop = True)
transaksi = transaksi[transaksi['status']==4].reset_index(drop=True)

#transaksi.head()

transaksi['date_from_new'] = transaksi['date_from'].apply(conv_to_date2)
transaksi['date_to_new'] = transaksi['date_to'].apply(conv_to_date2)
transaksi['update_time_new'] = transaksi['update_time'].apply(conv_to_date1)
transaksi['duration']=calc_days(transaksi)
transaksi['total_payment']=transaksi['duration']*transaksi['price']

curr = datetime(2019,12,31,0,0,0)
rfm = pd.DataFrame({'Monetary':transaksi.groupby(['id_user'])['total_payment'].sum(),
                    'Frequency':transaksi.groupby(['id_user'])['total_payment'].count(),
                    'Recency' : transaksi.groupby(['id_user']).apply(lambda x: -(curr - x['update_time_new'].max()).days)}).reset_index()

q_monetary = percentile(rfm['Monetary'], [20, 40, 60, 80])
q_frequency = percentile(rfm['Frequency'], [20, 40, 60, 80])
q_recency = percentile(rfm['Recency'], [20, 40, 60, 80])


rfm['level_monetary'] = levelling(rfm['Monetary'],q_monetary)
rfm['level_frequency'] = levelling(rfm['Frequency'],q_frequency)
rfm['level_recency'] = levelling(rfm['Recency'],q_recency)
rfm['freq_mon'] = (rfm['level_frequency'] + rfm['level_monetary']) / 2

segmen = []
for i in range(len(rfm)) : 
  if (2 <= rfm['level_recency'][i] <= 5) and (3 <= rfm['freq_mon'][i] <= 5) : 
    if (4 <= rfm['level_recency'][i] <= 5) and (4 <= rfm['freq_mon'][i] <= 5) : 
      segmen.append('Champion')
    else : 
      segmen.append('loyal customer')
  elif (3 <= rfm['level_recency'][i] <= 5) and (1 <= rfm['freq_mon'][i] <= 3) : 
    segmen.append('potential loyalist') 
  elif (4 <= rfm['level_recency'][i] <= 5) and (0 <= rfm['freq_mon'][i] <= 1) : 
    segmen.append('recent customer') 
  elif (3 <= rfm['level_recency'][i] <= 4) and (0 <= rfm['freq_mon'][i] <= 1) : 
    segmen.append('promising')
  elif (2 <= rfm['level_recency'][i] <= 3) and (2 <= rfm['freq_mon'][i] <= 3) : 
    segmen.append('customer needing attention')
  elif (2 <= rfm['level_recency'][i] <= 3) and (0 <= rfm['freq_mon'][i] <= 2) : 
    segmen.append('about to sleep')
  elif (0 <= rfm['level_recency'][i] <= 2) and (2 <= rfm['freq_mon'][i] <= 5) : 
    if (0 <= rfm['level_recency'][i] <= 1) and (4 <= rfm['freq_mon'][i] <= 5) : 
      segmen.append('cant lose them') 
    else : 
      segmen.append('at risk')
  elif (0 <= rfm['level_recency'][i] <= 2) and (0 <= rfm['freq_mon'][i] <= 2) : 
    if (1 <= rfm['level_recency'][i] <= 2) and (1 <= rfm['freq_mon'][i] <= 2) : 
      segmen.append('hibernating')
    else : 
      segmen.append('lost')

rfm['segmentation'] = segmen

#giving user's age
from dateutil.relativedelta import relativedelta

def cleansing_date (df) : 
  df['insert_time'] = [datetime.strptime(i, "%d-%m-%y %H:%M") for i in df['insert_time']] 
  df['last_login'] = [datetime.strptime(i, "%d-%m-%y %H:%M") for i in df['last_login'] ] 
  df['birth_date'] = [datetime.strptime(i, "%d-%m-%y") for i in df['birth_date']]
  return df

def calc_age(birth):
  age = relativedelta(datetime.now(),birth).years
  return age

users1 = cleansing_date(users1)
users1['age'] = users1['birth_date'].apply(calc_age)
user_rfm = users1.merge(rfm, how = 'left', on = 'id_user')

engine = create_engine('xxxx://xxxx:xxxx@xx.xx.xxx.xxx:5432/xxxx')
user_rfm.to_sql('rfm', engine, if_exists='replace', schema = 'public', index = False)